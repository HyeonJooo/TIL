## JWT

---
### JWT?
**JWT** = **J**SON **W**eb **T**oken<br>
= Json으로 되어 있는 토큰

서버에 토큰 정보를 저장할 필요가 없고, 서버는 해당 토큰이 유효한 지만 확인하면 된다.

---

## 1.JWT의 인증 프로세스

1. 유저가 ID, PW로 서버에 인증을 요청한다.
2. 서버에서 유저를 확인한 뒤, 토큰을 생성하여 유저에게 전달한다.
3. 유저는 해당 토큰을 가지고 서비스를 이용할 때마다 토큰과 함께 요청을 한다.
4. 서버는 들어오는 요청에서 토큰의 유효성을 검증한 뒤 서비스를 제공해준다.

---
[JWT 인증방식의 절차](#1.jwt의-인증-프로세스)
## JWT 구성
### JWT = Header + Payload + Signature

### 1. Header
헤더에는 서명에 어떤 암호화 알고리즘을 사용하고 있는지 + 토큰 타입을 담고 있다.

``` json
{
    "alg" : "HS256", 
    "typ" : "JWT"
}
```
**이를 Base64 인코딩한 값이 Header가 된다.**

<br>

### 2. Payload
페이로드에는 토큰에서 사용할 정보의 조각들인 **클레임**을 담는다.
(유저의 상태나 정보 등)

클레임의 종류는 다시 3가지로 나누어진다.

- 등록된 클레임
- 공개 클레임
- 비공개 클레임

### (1) **등록된 클레임**
**등록된 클레임**은 서비스에서 필요한 정보가 아닌, 토큰에 대한 정보들을 담기 위한 클레임이다. <br>

**등록된 클레임**은 모두 선택적으로 사용가능하며, 다음과 같은 종류들이 있다.

- **iss**: 토큰 발급자
- **sub**: 토큰 제목
- **aud**: 토큰 대상자
- **exp**: 토큰 만료시간 (시간은 NumericDate형식(14808495019230) 반드시 현재 시간보다 이후로 설정한다.)
- **iat**: 토큰 발급시간
- **nbf**: 이 날짜가 지나기 전까지는 토큰이 처리되지 않음
- **jti**: JWT의 고유 식별자로, 중복처리를 방직하기 위해 사용



<br>



### (2) **공개 클레임**
**공개 클레임**은 충돌이 방지된 이름을 가지고 있어야 한다. 이를 위해 클레임 이름을 **URL**형식으로 작성한다.
```json
{
  "https://example.com/jwt/claims": true
}
```

### (3) 비공개 클레임
**비공개 클레임**은 서버와 클라이언트 간의 협의 하에 사용하는 클레임이다.

<br>

``` json
{
    "iss" : "HyeonJooo", 
    "iat" : "1475874457",
    "exp" : "1475878357"
}
```
**이를 Base64 인코딩한 값이 Payload가 된다.**

<br>

### 3. Signature
서명은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 암호화 코드이다.

'Base64(Header).Base64(Payload)'를 **비밀키로 해싱**하고 그 결과값을 **Base64 인코딩**하면 **Signature**가 된다.

<br>

### 이렇게 만들어진 Header와 Payload와 Signature를 .으로 이으면 JWT가 된다!
![image](https://user-images.githubusercontent.com/58289478/108674553-d05f9a00-7528-11eb-9df5-74e6d10ed449.png)
(이미지 출처:https://smujihoon.tistory.com/239)

---

## JWT를 선택한 이유
JWT는 사용자를 인증하는 여러 방법 중 1가지 선택지일 뿐이다.<br>
세션을 통한 인증방식으로 사용자 인증을 할 수 있지만 이 방법 역시 장점과 단점이 존재하고 JWT는 이 단점을 보완해줄 수 있는 수단이다. (그러나 JWT 역시 단점이 존재한다.)

### 세션을 통한 인증 방식
기존의 세션을 통한 사용자 인증방식 절차를 간단히 설명하면 다음과 같다.
(1) 사용자가 ID, PW를 통해 로그인을 한다.<br>
(2) 서버에서 이를 확인한 후 세션값을 생성한다.<br>
(3) 서버에서 세션ID를 생성하여 유저에게 넘겨준다.<br>
(4) 유저는 이를 쿠키에 저장하고 서비스를 이용할 때마다 쿠키를 같이 넘겨준다.<br>
(5) 서버에서 쿠키를 검증한 뒤 서비스를 제공한다.<br>

### 세션 방식의 단점
이러한 세션 방식으로 사용자를 인증하는 방법에는 큰 단점이 존재하는데, 세션 정보를 **서버**에 저장한다는 것이다.<br>
따라서 서버에 큰 부하가 걸릴 수 있다는 것이 단점으로 부각되었고 이에 대한 문제를 해결하기 위해 나온 것이 JWT이다.




#1.jwt의 인증 프로세스
