## JWT

---
### JWT?
**JWT** = **J**SON **W**eb **T**oken<br>
= Json으로 되어 있는 토큰

서버에 토큰 정보를 저장할 필요가 없고, 서버는 해당 토큰이 유효한 지만 확인하면 된다.

---

## 1.JWT의 인증 프로세스

1. 유저가 ID, PW로 서버에 인증을 요청한다.
2. 서버에서 유저를 확인한 뒤, 토큰을 생성하여 유저에게 전달한다.
3. 유저는 해당 토큰을 가지고 서비스를 이용할 때마다 토큰과 함께 요청을 한다.
4. 서버는 들어오는 요청에서 토큰의 유효성을 검증한 뒤 서비스를 제공해준다.

---
## JWT 구성
### JWT = Header + Payload + Signature

### 1. Header
헤더에는 서명에 어떤 암호화 알고리즘을 사용하고 있는지 + 토큰 타입을 담고 있다.

``` json
{
    "alg" : "HS256", 
    "typ" : "JWT"
}
```
**이를 Base64 인코딩한 값이 Header가 된다.**

<br>

### 2. Payload
페이로드에는 토큰에서 사용할 정보의 조각들인 **클레임**을 담는다.
(유저의 상태나 정보 등)

클레임의 종류는 다시 3가지로 나누어진다.

- 등록된 클레임
- 공개 클레임
- 비공개 클레임

### (1) **등록된 클레임**
**등록된 클레임**은 서비스에서 필요한 정보가 아닌, 토큰에 대한 정보들을 담기 위한 클레임이다. <br>

**등록된 클레임**은 모두 선택적으로 사용가능하며, 다음과 같은 종류들이 있다.

- **iss**: 토큰 발급자
- **sub**: 토큰 제목
- **aud**: 토큰 대상자
- **exp**: 토큰 만료시간 (시간은 NumericDate형식(14808495019230) 반드시 현재 시간보다 이후로 설정한다.)
- **iat**: 토큰 발급시간
- **nbf**: 이 날짜가 지나기 전까지는 토큰이 처리되지 않음
- **jti**: JWT의 고유 식별자로, 중복처리를 방직하기 위해 사용



<br>



### (2) **공개 클레임**
**공개 클레임**은 충돌이 방지된 이름을 가지고 있어야 한다. 이를 위해 클레임 이름을 **URL**형식으로 작성한다.
```json
{
  "https://example.com/jwt/claims": true
}
```

### (3) 비공개 클레임
**비공개 클레임**은 서버와 클라이언트 간의 협의 하에 사용하는 클레임이다.

<br>

``` json
{
    "iss" : "HyeonJooo", 
    "iat" : "1475874457",
    "exp" : "1475878357"
}
```
**이를 Base64 인코딩한 값이 Payload가 된다.**

<br>

### 3. Signature
서명은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 암호화 코드이다.

'Base64(Header).Base64(Payload)'를 **비밀키로 해싱**하고 그 결과값을 **Base64 인코딩**하면 **Signature**가 된다.

<br>

### 이렇게 만들어진 Header와 Payload와 Signature를 .으로 이으면 JWT가 된다!
![image](https://user-images.githubusercontent.com/58289478/108674553-d05f9a00-7528-11eb-9df5-74e6d10ed449.png)
(이미지 출처:https://smujihoon.tistory.com/239)

---

## JWT를 선택한 이유
JWT는 사용자를 인증하는 여러 방법 중 1가지 선택지일 뿐이다.<br>
세션을 통한 인증방식으로 사용자 인증을 할 수 있지만 이 방법 역시 장점과 단점이 존재하고 JWT는 이 단점을 보완해줄 수 있는 수단이다. (그러나 JWT 역시 단점이 존재한다.)

### 세션을 통한 인증 방식
기존의 세션을 통한 사용자 인증방식 절차를 간단히 설명하면 다음과 같다.
(1) 사용자가 ID, PW를 통해 로그인을 한다.<br>
(2) 서버에서 이를 확인한 후 세션값을 생성한다.<br>
(3) 서버에서 세션ID를 생성하여 유저에게 넘겨준다.<br>
(4) 유저는 이를 쿠키에 저장하고 서비스를 이용할 때마다 쿠키를 같이 넘겨준다.<br>
(5) 서버에서 쿠키를 검증한 뒤 서비스를 제공한다.<br>

### 세션 방식의 단점
이러한 세션 방식으로 사용자를 인증하는 방법에는 큰 단점이 존재하는데, 세션 정보를 **서버**에 저장한다는 것이다.<br>
따라서 서버에 큰 부하가 걸릴 수 있다는 것이 단점으로 부각되었고 이에 대한 문제를 해결하기 위해 나온 것이 JWT이다.

### JWT의 방식
위 JWT의 인증방식 절차에서처럼 JWT에서는 **세션 값을 그냥 클라이언트에게 넘겨버린다.**
<br>
인증을 할 땐 토큰의 유효성을 검증하는 모듈만 만들어서 이를 통해 인증을 하고, 유저의 세션은 서버에서 가지고 있지 않는다.

---

### JWT의 장점

-  세션관리를 클라이언트에게 맡기기 때문에 서버부하가 적다.
- 별도의 인증 저장소가 필요없다.
- 무상태성(연결을 유지하지 않아도 데이터를 가져올 수 있다.)

<br>

### JWT의 단점

- 보안<br>
JWT방식의 인증은 세션을 클라이언트에서 관리한다. 따라서 중간에 패킷을 가로채는 등 토큰을 탈취당할 우려가 있다.<br>
따라서 유저의 민감한 정보는 클레임에 저장하지 않는 것을 권장한다.


- JWT는 한 번 생성되면 되돌릴 수 없다.<br>
만들어진 토큰을 임의로 삭제할 수 없기 때문에 만료시간을 설정해야 한다.<br>
또한, refresh토큰을 이용해 중간중간 토큰을 재발급하는 방식으로 관리한다.

  
- 정보가 많아질수록 토큰 길이가 길어진다.<br>
토큰 길이가 길어지면 네트워크 부하가 생길 수 있다.

---

## 내가 사용자 인증을 구현한 방법

- 사용자 인증은 JWT를 통해 구현하였다.
- 서버에서 JWT 토큰을 발급하여 클라이언트에게 넘겨주고 클라이언트에서는 이를 로컬 스토리지에 저장한다.
- 클라이언트에서 서버에게 서비스 요청을 할 때마다 토큰을 같이 넘겨준다.
- JWTInterceptor를 통해 토큰 유효성을 검증하고, 유효하다면 요청한 데이터를 넘겨준다.
- 만약 유효하지 않다면 메인화면으로 넘어가서 다시 로그인을 받게한다.
